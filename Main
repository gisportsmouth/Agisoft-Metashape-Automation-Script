"""
Created by M.Schaefer
v5 21/08/2018
"""

import PhotoScan
import os
from datetime import datetime

# Checking compatibility
compatible_major_version = '1.4'
found_major_version = '.'.join(PhotoScan.app.version.split('.')[:2])
if found_major_version != compatible_major_version:
    raise Exception('Incompatible PhotoScan version: {} != {}'
                        .format(found_major_version, compatible_major_version))
if not PhotoScan.app.document.path:
    raise Exception('Document not created yet, please save first')

class PS_Proc(object):
    """
    Create an object of type PhotoScan.app.document.
    Create menu items to process all or part of the Photoscan workflow.
    
    The object methods iterate through the chunks in the document and process 
        each in turn.
    """
    
    def __init__(self, doc, *, 
                    min_qual=.7, 
                    filtering=PhotoScan.MildFiltering, 
                    proj_acc=10, 
                    rec_uncert=10,
                    tp_pcnt=.1):
        """
        Initialise the object 
        
        Parameters: The current PhotoScan document
                    The minimum acceptable picture quality
                    The filter method
                    The projection accuracy
                    The reconstruction uncertainty
                    The percentage of points to aim for in gradual selection
        User Input: The output path for the export products
                    The filename prefix for export products
                    The filename will consist of the prefix, the name of 
                        the chunk and the type, (LAS, JPG, TIFF, 
                                                    DEM, Ortho etc.)
                        If the input is JPG the ortho output will be JPG too, 
                        otherwise the ortho will be TIFF.
        
        """
        self.path = PhotoScan.app.getExistingDirectory(
                        'Specify DSM/Ortho/Model export folder:')
        self.prefix = PhotoScan.app.getString(
                        label='Enter file prefix: ', value='')
        self.doc = doc
        self.min_qual = min_qual
        self.filtering = filtering
        self.proj_acc = proj_acc
        self.rec_uncert = rec_uncert
        self.tp_pcnt = tp_pcnt
        self.exp_crs = 0
        if not len(self.doc.chunks):
                raise Exception("No chunks!")
        self.chunks = self.doc.chunks
        #set logfile name to follow progress
        docname = os.path.basename(str(self.doc).strip('<,>').split()[1])[:-5]
        self.log = os.path.join(self.path, '{}_log_{}.txt'.
                        format(docname,
                                datetime.now().strftime("%Y-%m-%d %H-%M")))
        print('Log file to check progress: {}'.format(self.log))
        
    def info(self):
        """
        Output the current attributes of the object
        """
        print('The current path is: {}'.format(self.path))
        print('The current file name prefix is: {}'.format(self.prefix))
        print('The current minimum acceptable image quality is: {}'
                .format(self.min_qual))
        print('The current filtering method is: {}'.format(self.filtering))
        print('The current projection accuracy is: {}'.format(self.proj_acc))
        print('The current reconstruction accuracy is: {}'
                .format(self.rec_uncert))
        print('The current export CRS (EPSG Number) is [0 = project CRS]: {}'
                .format(self.exp_crs))
        
    def change_pre(self):
        self.prefix = PhotoScan.app.getString(
                        label='Enter file prefix: ', value='')
        
    def run_custom(self):
        """
        Change the object attributes for:
                    The minimum acceptable picture quality
                    The filter method
                    The projection accuracy
                    The reconstruction uncertainty
                    The export CRS
        """
        min_qual = PhotoScan.app.getFloat(
                        label='Enter picture quality threshold', value=0.7)
        filtering = PhotoScan.app.getString(
                        label=('Enter filtering mode (None, Mild, Moderate, '
                        'Aggressive)'), value='Mild')
        if filtering.lower() == 'mild':
            filtering = PhotoScan.MildFiltering
        elif filtering.lower() == 'moderate':
            filtering = PhotoScan.ModerateFiltering
        elif filtering.lower() == 'aggressive':
            filtering = PhotoScan.AggressiveFiltering
        elif filtering.lower() == 'none':
            filtering = PhotoScan.NoFiltering
        proj_acc = PhotoScan.app.getFloat(
                        label='Enter Projection Accuracy', value=10)
        rec_uncert = PhotoScan.app.getFloat(
                        label='Enter Reconstruction Uncertainty', value=10) 
        crs = PhotoScan.app.getInt(
                        label=('Enter export CRS if different from project CRS' 
                                '(EPSG Number)'), value=0)
        #initiate object
        self.min_qual = min_qual
        self.filtering = filtering
        self.proj_acc = proj_acc
        self.rec_uncert = rec_uncert
        self.exp_crs = crs
            
    def get_quality(self):
        """
        Estimate the image quality if not already present
        """
        for _ in self.chunks:
            qual = [i.meta['Image/Quality'] for i in _.cameras]
            if None in qual:
                _.estimateImageQuality(_.cameras)
  
    def disable_bad_pics(self, *, min_qual=None):
        """
        Disable any images below the threshold
        
        Parameter: min_qual=number (optional)
        Dependencies: self.get_quality())
        """
        if not min_qual:
            min_qual = self.min_qual
        for _ in self.chunks:
            self.get_quality()
            selected_cameras = [i for i in _.cameras
                                if float(i.meta['Image/Quality']) < min_qual]
            for camera in selected_cameras:
                camera.selected = True
                camera.enabled = False
            tot_cams = len(_.cameras)
            disabled = len(selected_cameras) 
            print(('{} out of {} disabled due to quality issues'
                    .format(disabled, tot_cams)))
            if disabled > tot_cams * .5:
                PhotoScan.app.messageBox('More than half the images are '
                                            'disabled, check your image quality'
                                            ' settings.')
                    
    def grad_sel(self, *, rec_uncert=None, 
                            repro_error=1, 
                            proj_acc=None,
                            adapt=True):
        """
        Run through a gradual selection process to remove erroneous tie points
        
        Parameters: rec_uncert=number, 
                    repro_error=number, 
                    proj_acc=number 
                    (all optional)
        
        Description: After the align process all tie points have errors attached
            to them. The values used are a matter of debate, the consensus seems
            to be to to aim for 10% of the original tie points created. This 
            method will eliminate tie points based on Reconstruction 
            Uncertainty, Projection Accuracy and Reprojection Error, all run 
            only once. The reprojection accuracy value is self-adjusting to 
            achieve just above the 10% value.
        """
        if not rec_uncert:
            rec_uncert = self.rec_uncert
        if not proj_acc:
            proj_acc = self.proj_acc
        for _ in self.chunks:
            #write log information
            with open(self.log, 'a+') as logfile:
                start_t =  datetime.now()
                logfile.write('Running gradual selection of {} at {} \n'.
                                            format(_, 
                                                start_t.strftime('%H:%M:%S')))
                logfile.write('    Reconstruction uncertainty: {} \n'\
                                '    Reprojection Error: {} \n'\
                                '    Projection Accuracy: {} \n'\
                                '    Aim to reduce to (%): {} \n'\
                                '    Adaptive fitting (%): {} \n'.
                                            format(rec_uncert, 
                                                    repro_error, 
                                                    proj_acc,
                                                    self.tp_pcnt,
                                                    adapt))
            f = PhotoScan.PointCloud.Filter()
            total_points = len([i for i in _.point_cloud.points])
            target_points = total_points * self.tp_pcnt
            #1 RecUncert
            print('Gradual selection - Reconstruction Uncertainty')
            f.init(_, criterion=PhotoScan.
                                PointCloud.
                                Filter.
                                ReconstructionUncertainty)
            f.removePoints(rec_uncert)
            _.optimizeCameras(adaptive_fitting=adapt)
            #2 ProjAcc
            print('Gradual selection - Projection Accuracy')
            f.init(_, criterion=PhotoScan.PointCloud.Filter.ProjectionAccuracy)
            f.removePoints(proj_acc)
            _.optimizeCameras(adaptive_fitting=adapt)
            #3 ReproError
            print('Gradual selection - Reprojection Error')
            adjust = 0
            step = 0.02
            f.init(_, criterion=PhotoScan.PointCloud.Filter.ReprojectionError)
            #find how many points need to be deleted after the first two steps
            points_remain = len([i for i in _.point_cloud.points])
            points_removed = total_points - points_remain
            updated_points =  points_remain - target_points
            while True:
                f.selectPoints(repro_error - adjust)
                sel = len([i for i in _.point_cloud.points if i.selected])
                pcent = 100 * (sel + points_removed) / total_points
                print('Points selected: {}, {} %'.format(sel, pcent))
                if sel < updated_points:
                    adjust += step
                    continue
                else:
                    adjust -= step
                    break
            f.selectPoints(repro_error - adjust)
            sel = len([i for i in _.point_cloud.points if i.selected])
            pcent = 100 * (sel + points_removed) / total_points
            print('Final points removed: {}, {} %'.format(sel, pcent))
            f.removePoints(repro_error - adjust)        
            _.optimizeCameras(adaptive_fitting=adapt)
            print('Total: {}, Target: {}'.format(total_points, target_points))
            #write log information
            with open(self.log, 'a+') as logfile:
                end_t = datetime.now()
                logfile = open(self.log, 'a+')
                logfile.write('Finished gradual selection {} at {} \n'.
                                            format(_, 
                                                end_t.strftime('%H:%M:%S')))
                logfile.write('    Final points removed: {}, {} % \n'.
                                                format(sel, pcent))
                logfile.write('    Total: {}, Reprojection error used: {} \n'.
                                            format(total_points, 
                                                repro_error - adjust))
                logfile.write('Processing time {} \n'.
                                                format(str(end_t - start_t)))
         
    def remove_align(self):
        """
        Remove the camera alignment
        """
        for _ in self.chunks:
            for c in _.cameras:
                c.transform = None
 
    def align(self, *, generic=False, 
                        filter = True, 
                        acc = PhotoScan.HighAccuracy,
                        key = 40000,
                        tie = 0,
                        adapt=True):
        #star forces named parameters
        """
        Align images in the document
        
        Parameters: generic=boolean (if not generic, reference pre-selection 
                                    is used)
        """
        if not generic:
            reference = True
        else:
            reference=False
        for _ in self.chunks:
            #write log information
            with open(self.log, 'a+') as logfile:
                start_t =  datetime.now()
                logfile.write('Aligning {} at {} \n'.
                                            format(_, 
                                                start_t.strftime('%H:%M:%S')))
                logfile.write('    Reference pre-selection: {} \n'.
                                                format(reference))
                logfile.write('    Accuracy: {} \n'\
                                '    Keypoint limit: {} \n'\
                                '    Tiepoint limit: {} \n'\
                                '    Adaptive fitting: {} \n'.
                                                    format(acc, 
                                                            key, 
                                                            tie, 
                                                            adapt))
            #start matching and aligning
            _.matchPhotos(accuracy=acc, 
                            generic_preselection=generic, 
                            reference_preselection=reference,
                            filter_mask=filter, 
                            keypoint_limit=key, 
                            tiepoint_limit=tie)
            _.alignCameras(adaptive_fitting=adapt)
            #write log information
            with open(self.log, 'a+') as logfile:
                end_t = datetime.now()
                logfile = open(self.log, 'a+')
                logfile.write('Finished aligning {} at {} \n'.
                                            format(_, 
                                                end_t.strftime('%H:%M:%S')))
                logfile.write('Processing time {} \n'.
                                                format(str(end_t - start_t)))
            self.doc.save()
     
    def dense_c(self, *, mode=None, qual=PhotoScan.HighQuality):
        """
        Create  dense point cloud
        
        Parameter: mode=[PhotoScan filtering method]
        """
        if not mode:
            mode = self.filtering
        for _ in self.chunks:
            #write log information
            with open(self.log, 'a+') as logfile:
                start_t =  datetime.now()
                logfile.write('Building point cloud {} at {} \n'.
                                            format(_, 
                                                start_t.strftime('%H:%M:%S')))
                logfile.write('    Quality: {} \n'\
                                '    Filtering mode: {} \n'.
                                        format(qual, mode))
            #build depthmaps and dense cloud
            _.buildDepthMaps(quality=qual, 
                                filter=mode)            
            _.buildDenseCloud(point_colors=True)
            #write log information
            with open(self.log, 'a+') as logfile:
                end_t = datetime.now()
                logfile.write('Finished generating point cloud {} at {} \n'.
                                                format(_, 
                                                    end_t.strftime('%H:%M:%S')))
                logfile.write('Processing time {} \n'.
                                                format(str(end_t - start_t)))
            self.doc.save()
              
    def build_model(self, *, surf=PhotoScan.Arbitrary,
                                inter=PhotoScan.EnabledInterpolation,
                                face=PhotoScan.MediumFaceCount,
                                map=PhotoScan.GenericMapping,
                                blend=PhotoScan.MosaicBlending,
                                m_size=4096):
        """
        Build a model from the dense point cloud
        """
        for _ in self.chunks:
            #if a MemoryError occurs in chunk other chunks are still processed
            try:
                #write log information
                with open(self.log, 'a+') as logfile:
                    start_t =  datetime.now()
                    logfile.write('Building  Model {} at {} \n'.
                                            format(_, 
                                                start_t.strftime('%H:%M:%S')))
                    logfile.write('    Surface type: {} \n'\
                                    '    Interpolation: {} \n'\
                                    '    Face count: {} \n'\
                                    '    Mapping: {} \n'\
                                    '    Blending: {} \n'\
                                    '    Mosaic size: {} \n'.
                                            format(surf, 
                                                    inter, 
                                                    face, 
                                                    map, 
                                                    blend, 
                                                    m_size))
                #Build model and texture                                
                _.buildModel(surface=surf, 
                                interpolation=inter,
                                face_count=face,
                                source=PhotoScan.DenseCloudData,
                                vertex_colors=True)
                _.buildUV(mapping=map)
                _.buildTexture(blending=blend, size=m_size)
                #write log information
                with open(self.log, 'a+') as logfile:
                    end_t = datetime.now()
                    logfile.write('Finished building model {} at {} \n'.
                                                format(_, 
                                                    end_t.strftime('%H:%M:%S')))
                    logfile.write('Processing time {} \n'.
                                                format(str(end_t - start_t)))
                self.doc.save()
            except MemoryError:
                print('A memory error occurred in chunk: {}'.format(_))
                #write log information
                with open(self.log, 'a+') as logfile:
                    start_t =  datetime.now()
                    logfile.write('***A memory error occurred in chunk: {}***'.
                                    format(_))
                continue
            
    def dem(self):
        """
        Build a DEM from the dense point cloud
        """
        for _ in self.chunks:
            #write log information
            with open(self.log, 'a+') as logfile:
                start_t =  datetime.now()
                logfile.write('Building DEM {} at {} \n'.
                                            format(_, 
                                                start_t.strftime('%H:%M:%S')))
            #build DEM                            
            _.buildDem(source=PhotoScan.DenseCloudData, 
                        interpolation=PhotoScan.EnabledInterpolation)
            #write log information
            with open(self.log, 'a+') as logfile:
                end_t = datetime.now()
                logfile.write('Finished building DEM {} at {} \n'.
                                                format(_, 
                                                    end_t.strftime('%H:%M:%S')))
                logfile.write('Processing time {} \n'.
                                                format(str(end_t - start_t)))
        self.doc.save()        
  
    def ortho(self, *, holes=True):
        """
        Build an ortho from the DEM
        """
        for _ in self.chunks:
            with open(self.log, 'a+') as logfile:
                start_t =  datetime.now()
                logfile.write('Generating Ortho {} at {} \n'.
                                            format(_, 
                                                start_t.strftime('%H:%M:%S')))
                logfile.write('    Fill holes = {}'.format(holes))
            _.buildOrthomosaic(surface=PhotoScan.ElevationData, 
                                blending=PhotoScan.MosaicBlending, 
                                fill_holes=holes)
            #write log information
            with open(self.log, 'a+') as logfile:
                end_t = datetime.now()
                logfile.write('Finished generating Ortho{} at {} \n'.
                                                format(_, 
                                                    end_t.strftime('%H:%M:%S')))
                logfile.write('Processing time {} \n'.
                                                format(str(end_t - start_t)))
        self.doc.save()
                                
    def export_geo(self):
        """
        Export LAS, DEM and Ortho to path using the file name prefix
        
        Ortho file format is JPG for JPG input images and TIF for all others, 
            unless the resulting JPG is > 65535 pixels, in which case a TIF will 
            be used.
        """
        jpg_limit = 65535
        for _ in self.chunks:
            #write log information
            with open(self.log, 'a+') as logfile:
                start_t =  datetime.now()
                logfile.write('Exporting {} at {} \n'.
                                            format(_, 
                                                start_t.strftime('%H:%M:%S')))
            ext = _.cameras[0].label[-3:]
            if self.exp_crs == 0:
                crs = _.crs
            else:
                crs = PhotoScan.CoordinateSystem('EPSG::{}'
                        .format(self.exp_crs))
            #check if input is JPG and below the limit            
            if (ext.upper() == 'JPG' 
                and not (_.orthomosaic.width > jpg_limit 
                        or _.orthomosaic.height > jpg_limit)):
                ext = 'jpg'
            else:
                ext = 'tif'
            if str(_)[8:-4] == 'Chunk':
                name = ''
                num = str(_)[-3]
            else:
                name = str(_)[8:-2]
                num = ''
            try:
                print('las crs: {}'.format(crs))
                file = '{}{}_LAS{}.las'.format(self.prefix, name, num)
                _.exportPoints(path = os.path.join(self.path, file),
                                format=PhotoScan.PointsFormatLAS,
                                projection=crs)
            except RuntimeError as e:
                if str(e) == 'Null point cloud':
                    print('There is no point cloud to export in chunk: {}'
                            .format(_))
                    continue
                else:
                    raise
            try:
                file = '{}{}_DSM{}.tif'.format(self.prefix, name, num)
                _.exportDem(path = os.path.join(self.path, file), 
                            write_world = True,
                            projection=crs)
            except RuntimeError as e:
                if str(e) == 'Null elevation':
                    print('There is no elevation to export in chunk: {}'
                            .format(_))
                    continue
                else:
                    raise
            try:
                file = '{}{}_Ortho{}.{}'.format(self.prefix, name, num, ext)
                _.exportOrthomosaic(path = os.path.join(self.path, file), 
                                    write_world = True,
                                    projection=crs)
            except RuntimeError as e:
                if str(e) == 'Null orthomosaic':
                    print('There is no orthomosaic to export in chunk: {}'
                            .format(_))
                    continue
                else:
                    raise
    
    def export_model(self):
        """
        Export LAS and OBJ to path using the file name prefix
        
        #Texture file format is JPG for JPG input images and TIF for all others.
        """
        for _ in self.chunks:
            #write log information
            with open(self.log, 'a+') as logfile:
                start_t =  datetime.now()
                logfile.write('Exporting {} at {} \n'.
                                            format(_, 
                                                start_t.strftime('%H:%M:%S')))
            #Texture JPG for now as Cloudcompare doesn't like the TIFF format
            ext = PhotoScan.ImageFormatJPEG
            """ext = _.cameras[0].label[-3:]
            if ext.upper() == 'JPG':
                ext = PhotoScan.ImageFormatJPEG
            else:
                ext = PhotoScan.ImageFormatTIFF"""
            if str(_)[8:-4] == 'Chunk':
                name = ''
                num = str(_)[-3]
            else:
                name = str(_)[8:-2]
                num = ''
            try:
                file = '{}{}_LAS{}.las'.format(self.prefix, name, num)
                _.exportPoints(path = os.path.join(self.path, file),
                                format=PhotoScan.PointsFormatLAS)
            except RuntimeError as e:
                if str(e) == 'Null point cloud':
                    print('There is no point cloud to export in chunk: {}'
                            .format(_))
                    continue
                else:
                    raise
            try:
                file = '{}{}_OBJ{}.obj'.format(self.prefix, name, num)
                _.exportModel(path = os.path.join(self.path, file),
                                texture_format=ext)
            except RuntimeError as e:
                if str(e) == 'Null model':
                    print('There is no model to export in chunk: {}'.format(_))
                    continue
                else:
                    raise
                 
    def run_geo(self, *, align=True, grad=False):
        if align:
            self.disable_bad_pics()
            self.align()
        if grad:
            self.grad_sel()
        self.dense_c()
        self.dem()
        self.ortho()
        self.export_geo()   
    
    #different running options for menu    
    def menu_geo_grad(self):
        self.run_geo(grad=True)
                
    def menu_geo_post_align(self):
        self.run_geo(align=False)
        
    def menu_geo_post_align_grad(self):
        self.run_geo(align=False, grad=True)
                
    def run_model(self, *, align=True, grad=False):
        if align:
            self.disable_bad_pics()
            self.align(generic=True)
        if grad:
            self.grad_sel()
        self.dense_c()
        self.build_model()
        self.export_model()
        
    def menu_model_grad(self):
        self.run_model(grad=True) 
        
    def menu_model_post_align(self):
        self.run_model(align=False)  
        
    def menu_model_post_align_grad(self):
        self.run_model(align=False, grad=True)  
        

def menu(label, method):
    """
    Creates a menu item in PS
    
    Input:  A label for the menu item (string)
            The method in the PS_Proc class to call
    """
    PhotoScan.app.addMenuItem(label, method)
     

#initiate object    
ps_doc = PS_Proc(PhotoScan.app.document)

#create menu options
menu('Custom/Remove alignment(optional)', ps_doc.remove_align)
menu('Custom/Calculate Image Quality', ps_doc.get_quality)
menu('Custom/Run - Geo (Check Projection Accuracy Value)', 
        ps_doc.run_geo)
menu('Custom/Run - Geo (gradual selection)(Check Projection Accuracy Value)', ps_doc.menu_geo_grad)
menu('Custom/Align - Geo', ps_doc.align)
menu('Custom/Run all after alignment - Geo (Check Projection Accuracy Value)', 
        ps_doc.menu_geo_post_align)
menu('Custom/Run all after alignment - Geo (gradual selection)(Check Projection Accuracy Value)', 
        ps_doc.menu_geo_post_align_grad)
menu('Custom/Run - 3D Model', ps_doc.run_model)
menu('Custom/Run - 3D Model (gradual selection)', ps_doc.menu_model_grad)
menu('Custom/Align - 3D Model', ps_doc.align)
menu('Custom/Run all after alignment - 3D Model', ps_doc.menu_model_post_align)
menu('Custom/Run all after alignment - 3D Model (gradual selection)', 
                                            ps_doc.menu_model_post_align_grad)
menu('Change Values/Get current parameter info', ps_doc.info)
menu('Change Values/Change file prefix', ps_doc.change_pre) 
menu('Change Values/Enter custome values', ps_doc.run_custom) 
